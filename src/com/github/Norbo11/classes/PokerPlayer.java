/* ==================================================================================================
 * UltimatePoker v1.0 - By Norbo11
 * Copyright (C) 2012
 * You may NOT modify this file in any way, or use any of it's code for personal projects. 
 * You may, however, read and learn from it if you like. All rights blah blah and shit. 
 * Basically just respect my hard work, please :)
 * 
 * File notes: PokerPlayer.java
 * -Provides necessary methods which are called when the plaeyr is playing
 * -Stuff like calling, folding, checking, going all in, and much more are all in here
 * -Note: all checks for the methods (for example, checking if the player has enough money to
 * call) are done in the MethodsHand class.
 * ===================================================================================================
 */

package com.github.norbo11.classes;

import java.util.ArrayList;
import java.util.List;

import org.bukkit.ChatColor;
import org.bukkit.Location;
import org.bukkit.entity.Player;

import com.github.norbo11.UltimatePoker;

public class PokerPlayer
{
    public PokerPlayer(Player player, Table table, double buyin, UltimatePoker p)
    {
        this.p = p;
        this.player = player;
        this.table = table;
        startLocation = player.getLocation();

        online = true;
        
        action = false;
        acted = false;
        folded = false;
        eliminated = false;
        blind = false;
        revealed = false;
        
        pot = null;
        currentBet = 0;
        totalBet = 0;
        id = table.getEmptyID();
        money = buyin;
        name = player.getName();

    }

    UltimatePoker p;
    public Player player;
    public String name;
    public Location startLocation; //Used to teleport the player back to the location where he/she joined
    public Table table;
    public Pot pot;                //This is null if the player is not all in. It turns to an actual pot which represents the pot which the player created by going all in.
    
    public boolean owner;          //This is true if the player is an owner of a table.
    public boolean action;         //True if it's the player's turn
    public boolean acted;          //True if the player has acted at least once
    public boolean folded;         
    public boolean eliminated;     //When the player gets eliminated this is set to true (eliminated means runs out of money)
    public boolean blind;          //True if the player is the big blind
    public boolean online;
    public boolean revealed;
    public double currentBet;      //This simply represents the player's current bet in the phase. (phase = flop, turn, river, etc)
    public double totalBet;        //This is the total amount that the player has bet in the hand
    public double money;           //This is the player's stack
    public int id;                 //ID of the player

    public List<Card> cards = new ArrayList<Card>(); //This holds the player's hand

    //Adds cards to the player's hand. The cards should be generated by deck.generateCards(number).
    public void addCards(Card[] cards)
    {
        List<Card> addedCards = new ArrayList<Card>();
        for (int i = 0; i < cards.length; i++)
        {
            addedCards.add(cards[i]);
            sendMessage(p.pluginTag + "You have been dealt the " + addedCards.get(i).toString());
        }
        this.cards.addAll(addedCards);
    }

    //Declares the player all-in
    public void allIn()
    {
        action = false;
        acted = true;

        double amount = money;            //Amount that the player is going all in for (all his stack)

        // Bet
        currentBet = currentBet + amount; //Increase the player's current bet my the amount that he's going all in for
        totalBet = totalBet + amount;     //Increase his total bet by that amount also

        double sidePot = 0;               //This variable decides what the sidepot amount is going to be

        double[] temp = new double[table.players.size()]; //New array of doubles, with the size of the amuont of players. 
                                                          //It holds all players that have bet at least the amount that the player is going all in for in that phase
        int i = 0;
        //Gets all non folded players who have bet at least the amount that the player is going all in for (in that phase) and stores the amounts that they have bet in excess in temp
        for (PokerPlayer player : table.getNonFoldedPlayers())
        {
            if (player.currentBet >= currentBet && player != this) temp[i] = player.currentBet - currentBet;
            i++;
        }
        //Iterates through temp and makes the sidepot equal to the amount that the player is short (that is, all the current bets of the players that are over the all in amount, summed up)
        for (double temp2 : temp)
            sidePot = sidePot + temp2;

        //Makes a new pot with the obtained sidepot amount, adds the pot to the list of table pots, and sets the latestPot variable to the created pot.
        pot = new Pot(this, table, sidePot, table.pots.size(), p);
        table.pots.add(pot);
        table.latestPot = pot;
        
        /* Sets the pot before the one just created (effectively latestPot - 1 in index of pots) to its amount, minus the created side pot, plus the amount that the player is going all in for.
         * This means "take away what the player is short from the previous pot (usually the main pot), and put it in the new side pot. Then add the amount that the player is actually
         * covering to the pot before this one (usually the main pot)
         */
        
        table.pots.get(table.pots.indexOf(table.latestPot) - 1).pot = (table.pots.get(table.pots.indexOf(table.latestPot) - 1).pot - sidePot) + amount;

        // Since the player is going all in, deduct all of his money
        money = 0;

        //Send messages
        p.methodsMisc.sendToAllWithinRange(table.location, p.pluginTag + p.gold + player.getName() + p.white + " is all in for " + p.gold + p.methodsMisc.formatMoney(amount) + p.white + "! (Total: " + p.gold + p.methodsMisc.formatMoney(totalBet) + p.white + ")");
        p.methodsMisc.sendToAllWithinRange(table.location, p.pluginTag + "Created side pot of " + p.gold + p.methodsMisc.formatMoney(sidePot) + p.white + "!");

        //If there is only 1 non all-in player left on the table, go to showdown
        if (table.players.size() - 1 == table.getAllInPlayers().size())
        {
            table.showdown();
            return; //If you're going to showdown, return so that it doesn't go to next the next person's turn
        }
       
        table.nextPersonTurn(this);         //Go to the next person's turn
    }

    //This method is only called when raising or betting for the first time in the phase. You cannot bet less than the current bet of the table
    public void bet(double amount)
    {
        action = false;
        acted = true;
        double tableCurrentBet = table.currentBet;          //The table current bet prior to the raise
        double alreadyContributed = currentBet;             //The amount that the player has already put in the pop prior to the raise
        double raised = amount - alreadyContributed;        //The amount that is actually being raised (so, the amount over the current bet of the player that is raising)
        double allInCover = raised - table.latestPot.pot;   //The cover for the latest all in.

        //Set the table current bet to the new amount, add the raised amount to the player's total, and set the player's current bet to the amount of the raise/bet
        currentBet = amount;
        totalBet = totalBet + raised;
        table.currentBet = amount;

        //If there is more than 1 pot (effectively, if there is a side pot) and that pot was created during the current phase
        if (table.pots.size() > 1 && table.latestPot.phase == table.currentPhase)
        {
            //Cover the all in with the allInCover amount, by putting it in the 2nd to latest pot (most likely the main pot)
            table.pots.get(table.pots.indexOf(table.latestPot) - 1).pot = table.pots.get(table.pots.indexOf(table.latestPot) - 1).pot + allInCover;
            table.latestPot.pot = table.latestPot.pot + (raised - allInCover);     //Increase the side pot with the amount that is over the all in cover.
        } else table.latestPot.pot = table.latestPot.pot + raised;                 //If there were no all in's during this phase simply add the raised amount to the latest pot

        //If the original current bet of the table was 0, say that the player has "bet" (first time that someone adds money to the pot during the phase)
        if (tableCurrentBet == 0) 
        {
            p.methodsMisc.sendToAllWithinRange(table.location, p.pluginTag + p.gold + player.getName() + p.white + " bets " + p.gold + p.methodsMisc.formatMoney(amount) + p.white + " (Total: " + p.gold + p.methodsMisc.formatMoney(totalBet) + p.white + ")");
        } else //If there was a bet already, declare it a raise
        {
            p.methodsMisc.sendToAllWithinRange(table.location, p.pluginTag + p.gold + player.getName() + p.white + " raises to " + p.gold + p.methodsMisc.formatMoney(amount) + p.white + " (Total: " + p.gold + p.methodsMisc.formatMoney(totalBet) + p.white + ")");
        }
        
        // Deduct the raised amount from the player's stack
        money = money - raised;

        table.nextPersonTurn(this);        //Go to the next person's turn
    }

    public void call()
    {
        action = false;
        acted = true;

        double called = table.currentBet - currentBet;     //Amount of money that is being called
        double allInCover = called - table.latestPot.pot;  //The cover for the latest all in.

        // Call, by simply adding the amount of money being called to the player's current and total bet
        currentBet = currentBet + called;
        totalBet = totalBet + called;

        //If there is more than 1 pot (effectively, if there is a side pot) and that pot was created during the current phase
        if (table.pots.size() > 1 && table.latestPot.phase == table.currentPhase)
        {
            //Cover the all in with the allInCover amount, by putting it in the 2nd to latest pot (most likely the main pot)
            table.pots.get(table.pots.indexOf(table.latestPot) - 1).pot = table.pots.get(table.pots.indexOf(table.latestPot) - 1).pot + allInCover;
            table.latestPot.pot = table.latestPot.pot + (called - allInCover);     //Increase the side pot with the amount that is over the all in cover.
        } else table.latestPot.pot = table.latestPot.pot + called;                 //If there were no all in's during this phase simply add the called amount to the latest pot

        // Deduct the amount of money being called from the player's stack
        money = money - called;

        p.methodsMisc.sendToAllWithinRange(table.location, p.pluginTag + p.gold + player.getName() + p.white + " calls " + p.gold + p.methodsMisc.formatMoney(called) + p.white + " (Total: " + p.gold + p.methodsMisc.formatMoney(totalBet) + p.white + ")");
        table.nextPersonTurn(this); //After announcing that the player has called go to the next player's turn
    }

    public void check()
    {
        //Simply say that the player has took action, and just send a message. Then go to the next player's turn
        action = false;
        acted = true;
        p.methodsMisc.sendToAllWithinRange(table.location, p.pluginTag + p.gold + player.getName() + p.white + " has checked.");
        table.nextPersonTurn(this);
    }
    
    //Clears the player's hand
    public void clearHand()
    {
        cards.clear();
    }

    //Displays the player's hand (to himself only)
    public void displayHand()
    {
        sendMessage(p.pluginTag + "Your hand:");
        sendMessage(p.pluginTag + p.gold + p.lineString);
        sendMessage(hand());
    }

    //Displays the player's money (to himself only)
    public void displayMoney()
    {
        sendMessage(p.pluginTag + "You have " + p.gold + p.methodsMisc.formatMoney(money) + p.white + " left on this table.");
    }

    //Displays all pots at the table (to the player only)
    public void displayPot()
    {
        for (String temp : table.listPots())
            sendMessage(temp);
    }

    //Eliminates the player by setting their eliminated flag to true and teleporting them to their starting location
    public void eliminate()
    {
        p.methodsMisc.sendToAllWithinRange(table.location, p.pluginTag + p.gold + player.getName() + p.white + " has been eliminated!");
        eliminated = true;
        player.teleport(startLocation);
    }

    //Clears the player's hand, sets their folded flag to true and displays a message. Then goes to the turn of the next player
    public void fold()
    {
        action = false;
        acted = true;
        folded = true;
        p.methodsMisc.sendToAllWithinRange(table.location, p.pluginTag + p.gold + player.getName() + p.white + " has folded.");
        clearHand();
        table.nextPersonTurn(this);
    }

    //Simply a short method to get the current balance of this poker player from the economy
    public double getBalance()
    {
        return p.economy.getBalance(player.getName());
    }

    //Returns an array which represents the string representation of each card in the player's hand
    public String[] hand()
    {
        String[] returnValue = new String[cards.size()];
        int i = 0;
        //Go through all cards, add them to the temporary array and then return the array.
        for (Card card : cards)
        {
            returnValue[i] = p.pluginTag + "[" + i + "] " + card.toString();
            i++;
        }
        return returnValue;
    }

    /*
     * Makes this player posts a blind. The argument should be one of the three:
     * "small" - for the small blind
     * "big" - for the big blind
     * "ante" - for the ante
     */
    public void postBlind(String blind)
    {
        //Go through all possible blind types and set the amount variable to the corresponding value in the table settings
        double amount = 0;
        if (blind.equals("small"))
        {
            amount = table.sb;
            p.methodsMisc.sendToAllWithinRange(table.location, p.pluginTag + p.gold + player.getName() + p.white + " has posted the small blind (" + p.gold + p.methodsMisc.formatMoney(amount) + p.white + ")");
        }
        if (blind.equals("big"))
        {
            amount = table.bb;
            p.methodsMisc.sendToAllWithinRange(table.location, p.pluginTag + p.gold + player.getName() + p.white + " has posted the big blind (" + p.gold + p.methodsMisc.formatMoney(amount) + p.white + ")");
        }
        if (blind.equals("ante"))
        {
            amount = table.ante;
            p.methodsMisc.sendToAllWithinRange(table.location, p.pluginTag + p.gold + player.getName() + p.white + " has posted the ante (" + p.gold + p.methodsMisc.formatMoney(amount) + p.white + ")");
        }

        //Set the player's current bet to the blind, add the blind to their total amount, set the table's current bet to the amount, add the blind to the main pot, deduct money from the player
        currentBet = amount;
        totalBet = totalBet + amount;
        table.currentBet = amount;
        table.pots.get(0).pot = table.pots.get(0).pot + amount;
        money = money - amount;
    }

    //Called whenever the player wants to add more money to his/her stack (/hand rebuy)
    public void reBuy(double amount)
    {
        //Withdraw the desired amount from the economy, add it to their stack, then display the message
        p.economy.withdrawPlayer(player.getName(), amount);
        p.methodsMisc.addToLog(p.getDate() + " [ECONOMY] Withdrawing " + amount + " from " + player.getName());
        money = money + amount;
        p.methodsMisc.sendToAllWithinRange(table.location, p.pluginTag + p.gold + player.getName() + p.white + " has added " + p.gold + p.methodsMisc.formatMoney(amount) + p.white + " to his stack. New balance: " + p.gold + p.methodsMisc.formatMoney(money));
        //If the player was eliminated then get them back into the game
        if (eliminated == true)
        {
            p.methodsMisc.sendToAllWithinRange(table.location, p.pluginTag + p.gold + player.getName() + p.white + " is now back in the game!");
            eliminated = false;
        }
    }

    //Publicly reveals the player's hand to everybody
    public void revealHand()
    {
        revealed = true;
        acted = true;
        action = false;
        p.methodsMisc.sendToAllWithinRange(table.location, p.pluginTag + p.gold + player.getName() + p.white + "'s hand:");
        p.methodsMisc.sendToAllWithinRange(table.location, hand());
        table.nextPersonTurn(this);
    }
    
    //Simply a shortcut method to send a message just to this poker player
    public void sendMessage(String message)
    {
        player.sendMessage(message);
    }
    
    //Same as above except it takes an array argument
    public void sendMessage(String[] message)
    {
        player.sendMessage(message);
    }

    //Sets the player's action flag to true and gives them an eye-catching message
    public void takeAction()
    {
        sendMessage(p.pluginTag + ChatColor.DARK_PURPLE + ChatColor.UNDERLINE + "It's your turn to act!");
        action = true;
    }

    public void invite(Player toInvite)
    {
        toInvite.sendMessage(p.pluginTag + p.gold + name + p.white + " has invited you to his/her poker table! Sit with " + p.gold + "/poker sit " + id + " [buy-in]");
        player.sendMessage(p.pluginTag + "You have invited " + p.gold + toInvite.getName() + p.white + " to your table.");
    }
}
