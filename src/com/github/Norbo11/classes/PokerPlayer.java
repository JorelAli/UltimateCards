/* ==================================================================================================
 * UltimatePoker v1.1 - By Norbo11
 * Copyright (C) 2012
 * You may NOT modify this file in any way, or use any of it's code for personal projects. 
 * You may, however, read and learn from it if you like. All rights blah blah and shit. 
 * Basically just respect my hard work, please :)
 * 
 * File notes: PokerPlayer.java
 * -Provides necessary methods which are called when the plaeyr is playing
 * -Stuff like calling, folding, checking, going all in, and much more are all in here
 * -Note: all checks for the methods (for example, checking if the player has enough money to
 * call) are done in the MethodsHand class.
 * ===================================================================================================
 */

package com.github.norbo11.classes;

import java.util.ArrayList;
import java.util.List;

import org.bukkit.ChatColor;
import org.bukkit.Location;
import org.bukkit.entity.Player;

import com.github.norbo11.UltimatePoker;
import com.github.norbo11.stats.Stats;

public class PokerPlayer
{
    public PokerPlayer(Player player, Table table, double buyin, UltimatePoker p) throws Exception
    {
        this.p = p;
        this.table = table;
        startLocation = player.getLocation();

        online = true;

        action = false;
        acted = false;
        folded = false;
        eliminated = false;
        blind = false;
        revealed = false;
        allIn = 0;
        name = player.getName();
        stats = p.methodsStats.createStats(this);
        // stats.saveStats();

        pot = null;
        currentBet = 0;
        totalBet = 0;
        wonThisHand = 0;
        id = table.getEmptyID();
        money = buyin;
    }

    UltimatePoker p;
    public final String name;            // This holds the player's name. Should never be changed
    public final Location startLocation; // Used to teleport the player back to the location where he/she joined
    public final Table table;            // This holds the table that the player is sitting at
    public Pot pot;                // This is null if the player is not all in. It turns to an actual pot which represents the pot which the player created by going all in.
    public Stats stats;            // This is an object which holds methods and a list of every single statistic associated with this player

    public boolean owner;          // This is true if the player is an owner of a table.
    public boolean action;         // True if it's the player's turn
    public boolean acted;          // True if the player has acted at least once
    public boolean folded;
    public boolean eliminated;     // When the player gets eliminated this is set to true (eliminated means runs out of money)
    public boolean blind;          // True if the player is the big blind
    public boolean online;
    public boolean revealed;
    public double allIn;
    public double currentBet;      // This simply represents the player's current bet in the phase. (phase = flop, turn, river, etc)
    public double totalBet;        // This is the total amount that the player has bet in the hand
    public double money;           // This is the player's stack
    public double wonThisHand;
    public int id;                 // ID of the player

    public List<Card> cards = new ArrayList<Card>(); // This holds the player's hand

    // Adds cards to the player's hand. The cards should be generated by deck.generateCards(number).
    public void addCards(Card[] cards)
    {
        List<Card> addedCards = new ArrayList<Card>();
        for (int i = 0; i < cards.length; i++)
        {
            addedCards.add(cards[i]);
            sendMessage(p.PLUGIN_TAG + "You have been dealt the " + addedCards.get(i).toString());
        }
        this.cards.addAll(addedCards);
    }

    // Declares the player all-in
    public void allIn()
    {
        double amount = money;            // Amount that the player is going all in for (all his stack)

        allIn = totalBet + amount;
        action = false;
        acted = true;

        // Bet
        totalBet = totalBet + amount;     // Increase his total bet by that amount also
        currentBet = currentBet + amount; // Increase the player's current bet my the amount that he's going all in for

        double sidePot = 0;               // This variable decides what the sidepot amount is going to be

        double[] temp = new double[table.players.size()]; // New array of doubles, with the size of the amount of players.
                                                          // It holds all players that have bet at least the amount that the player is going all in for in that phase
        int i = 0;
        // Gets all non folded players who have bet at least the amount that the player is going all in for (in that phase) and stores the amounts that they have bet in excess in temp
        for (PokerPlayer player : table.getNonFoldedPlayers())
        {
            if (player.currentBet >= currentBet && player != this) temp[i] = player.currentBet - currentBet;
            i++;
        }
        // Iterates through temp and makes the sidepot equal to the amount that the player is short (that is, all the current bets of the players that are over the all in amount, summed up)
        for (double temp2 : temp)
            sidePot = sidePot + temp2;

        boolean sameAmount = false;
        for (Pot pot : table.pots)
        {
            if (!pot.main)
            {
                if (pot.playerAllIn.allIn == allIn)
                {
                    double allInCover = 0;
                    for (Pot pot2 : table.pots)
                    {
                        if (!pot2.main && pot2.playerAllIn != this)
                        {
                            if (pot2.playerAllIn.allIn > table.pots.get(table.pots.indexOf(pot2) - 1).getContribution(this))
                            {
                                allInCover = allInCover + (table.pots.get(table.pots.indexOf(pot2) - 1).getContribution(pot2.playerAllIn) - table.pots.get(table.pots.indexOf(pot2) - 1).getContribution(this));
                                table.pots.get(table.pots.indexOf(pot2) - 1).contribute(this, table.pots.get(table.pots.indexOf(pot2) - 1).getContribution(pot2.playerAllIn) - table.pots.get(table.pots.indexOf(pot2) - 1).getContribution(this), false);
                                table.pots.get(table.pots.indexOf(pot2) - 1).adjustPot();
                            }
                        }
                    }
                    table.pots.get(table.pots.indexOf(table.latestPot) - 1).contribute(this, amount - allInCover, false);
                    table.pots.get(table.pots.indexOf(table.latestPot) - 1).adjustPot();
                    sameAmount = true;
                    break;
                }
            }
        }
        if (sidePot > 0 && !sameAmount)
        {

            // Makes a new pot with the obtained sidepot amount, adds the pot to the list of table pots, and sets the latestPot variable to the created pot.
            pot = new Pot(this, table, sidePot, table.pots.size(), p);
            table.pots.add(pot);
            table.latestPot = pot;
            // This for loop goes through every non folded player. If the player has bet more on the current phase than the player going all in,
            // take how much we are short of their current bet. Then lower their contribution amount on the pot before the side pot just created, created and put it in the side pot.
            double boosack = 0;
            for (PokerPlayer player : table.getNonFoldedPlayers())
            {
                if (player.currentBet >= currentBet && player != this)
                {
                    table.pots.get(table.pots.indexOf(pot) - 1).contribute(player, table.pots.get(table.pots.indexOf(pot) - 1).getContribution(player) - (player.currentBet - currentBet), true);
                    pot.contribute(player, player.currentBet - currentBet, false);
                    boosack = boosack + (player.currentBet - currentBet);
                }
            }
            // This goes through every single pot and contributes whatever is needed to each pot (whatever is needed is defined by the player's all in amount of that pot)
            // We have to match that amount so we set our contribution level to that amount. We also store the total amount of money we covered so that we can take it
            // away from our all in amount once we contribute to the pot before our side pot.
            double allInCover = 0;
            for (Pot pot : table.pots)
            {
                if (!pot.main && pot.playerAllIn != this)
                {
                    if (pot.playerAllIn.allIn > table.pots.get(table.pots.indexOf(pot) - 1).getContribution(this))
                    {
                        allInCover = allInCover + (table.pots.get(table.pots.indexOf(pot) - 1).getContribution(pot.playerAllIn) - table.pots.get(table.pots.indexOf(pot) - 1).getContribution(this));
                        table.pots.get(table.pots.indexOf(pot) - 1).contribute(this, table.pots.get(table.pots.indexOf(pot) - 1).getContribution(pot.playerAllIn) - table.pots.get(table.pots.indexOf(pot) - 1).getContribution(this), false);
                        table.pots.get(table.pots.indexOf(pot) - 1).adjustPot();
                    }
                }
            }
            table.pots.get(table.pots.indexOf(pot) - 1).contribute(this, amount - allInCover, false);
            table.pots.get(table.pots.indexOf(pot) - 1).adjustPot();
        } else if (sidePot == 0 && !sameAmount)
        {
            table.currentBet = currentBet;
            double allInCover = 0;
            for (Pot pot : table.pots)
            {
                if (!pot.main && pot.playerAllIn != this)
                {
                    if (pot.playerAllIn.allIn > table.pots.get(table.pots.indexOf(pot) - 1).getContribution(this))
                    {
                        allInCover = allInCover + (table.pots.get(table.pots.indexOf(pot) - 1).getContribution(pot.playerAllIn) - table.pots.get(table.pots.indexOf(pot) - 1).getContribution(this));
                        table.pots.get(table.pots.indexOf(pot) - 1).contribute(this, table.pots.get(table.pots.indexOf(pot) - 1).getContribution(pot.playerAllIn) - table.pots.get(table.pots.indexOf(pot) - 1).getContribution(this), false);
                        // table.pots.get(table.pots.indexOf(pot) - 1).even(pot.playerAllIn);
                        table.pots.get(table.pots.indexOf(pot) - 1).adjustPot();
                    }
                }
            }
            table.latestPot.contribute(this, amount - allInCover, false);
            table.latestPot.adjustPot();
        }

        table.adjustPots();
        // Since the player is going all in, deduct all of his money
        money = 0;

        // Send messages
        p.methodsMisc.sendToAllWithinRange(table.location, p.PLUGIN_TAG + p.gold + name + p.white + " is all in for " + p.gold + p.methodsMisc.formatMoney(amount) + p.white + "! (Total: " + p.gold + p.methodsMisc.formatMoney(totalBet) + p.white + ")");
        if (sidePot > 0 && !sameAmount) p.methodsMisc.sendToAllWithinRange(table.location, p.PLUGIN_TAG + "Created side pot of " + p.gold + p.methodsMisc.formatMoney(sidePot) + p.white + "!");

        stats.adjustStats("allIn", amount);
        table.nextPersonTurn(this);         // Go to the next person's turn

    }

    // This method is only called when raising or betting for the first time in the phase. You cannot bet less than the current bet of the table
    public void bet(double amount)
    {
        double tableCurrentBet = table.currentBet;          // The table current bet prior to the raise
        double alreadyContributed = currentBet;             // The amount that the player has already put in the pop prior to the raise
        double raised = amount - alreadyContributed;        // The amount that is actually being raised (so, the amount over the current bet of the player that is raising)

        // If the player has bet all of their money, go all in instead of going through this method
        if (money - raised == 0)
        {
            allIn();
            return;
        }

        action = false;
        acted = true;

        // Set the table current bet to the new amount, add the raised amount to the player's total, and set the player's current bet to the amount of the raise/bet
        currentBet = amount;
        totalBet = totalBet + raised;
        table.currentBet = amount;

        if (table.pots.size() > 1 && table.latestPot.phase == table.currentPhase)
        {
            double allInCover = 0;
            for (Pot pot : table.pots)
            {
                if (!pot.main && pot.playerAllIn != this)
                {
                    if (pot.playerAllIn.allIn > table.pots.get(table.pots.indexOf(pot) - 1).getContribution(this))
                    {
                        allInCover = allInCover + (table.pots.get(table.pots.indexOf(pot) - 1).getContribution(pot.playerAllIn) - table.pots.get(table.pots.indexOf(pot) - 1).getContribution(this));
                        table.pots.get(table.pots.indexOf(pot) - 1).contribute(this, table.pots.get(table.pots.indexOf(pot) - 1).getContribution(pot.playerAllIn) - table.pots.get(table.pots.indexOf(pot) - 1).getContribution(this), false);
                        table.pots.get(table.pots.indexOf(pot) - 1).adjustPot();
                    }
                }
            }
            table.latestPot.contribute(this, raised - allInCover, false);
            // if (allInCover == 0) table.pots.get(table.pots.indexOf(pot) - 1).even(this);
            table.latestPot.adjustPot();
        } else
        {
            table.latestPot.contribute(this, raised, false);
            table.latestPot.adjustPot();
        }

        table.adjustPots();
        // If the original current bet of the table was 0, say that the player has "bet" (first time that someone adds money to the pot during the phase)
        if (tableCurrentBet == 0) p.methodsMisc.sendToAllWithinRange(table.location, p.PLUGIN_TAG + p.gold + name + p.white + " bets " + p.gold + p.methodsMisc.formatMoney(amount) + p.white + " (Total: " + p.gold + p.methodsMisc.formatMoney(totalBet) + p.white + ")");
        // If there was a bet already, declare it a raise
        else p.methodsMisc.sendToAllWithinRange(table.location, p.PLUGIN_TAG + p.gold + name + p.white + " raises to " + p.gold + p.methodsMisc.formatMoney(amount) + p.white + " (Total: " + p.gold + p.methodsMisc.formatMoney(totalBet) + p.white + ")");
        // Deduct the raised amount from the player's stack
        money = money - raised;
        // If it was a bet
        if (tableCurrentBet == 0) stats.adjustStats("bet", amount);
        // If it was a raise
        if (tableCurrentBet != 0) stats.adjustStats("raise", amount - tableCurrentBet);
        table.nextPersonTurn(this);
    }

    public void call()
    {
        double called = table.currentBet - currentBet;     // Amount of money that is being called
        // double allInCover = called - table.latestPot.pot; // The cover for the latest all in.

        if (money - called == 0)
        {
            allIn();
            return;
        }

        action = false;
        acted = true;

        // Call, by simply adding the amount of money being called to the player's current and total bet
        currentBet = currentBet + called;
        totalBet = totalBet + called;

        // If there is more than 1 pot (effectively, if there is a side pot) and that pot was created during the current phase
        if (table.pots.size() > 1 && table.latestPot.phase == table.currentPhase)
        {
            double allInCover = 0;
            for (Pot pot : table.pots)
            {
                if (!pot.main && pot.playerAllIn != this)
                {
                    if (pot.playerAllIn.allIn > table.pots.get(table.pots.indexOf(pot) - 1).getContribution(this))
                    {
                        allInCover = allInCover + (table.pots.get(table.pots.indexOf(pot) - 1).getContribution(pot.playerAllIn) - table.pots.get(table.pots.indexOf(pot) - 1).getContribution(this));
                        table.pots.get(table.pots.indexOf(pot) - 1).contribute(this, table.pots.get(table.pots.indexOf(pot) - 1).getContribution(pot.playerAllIn) - table.pots.get(table.pots.indexOf(pot) - 1).getContribution(this), false);
                        table.pots.get(table.pots.indexOf(pot) - 1).adjustPot();
                    }
                }
            }
            table.latestPot.contribute(this, called - allInCover, false);
            // if (allInCover == 0) table.pots.get(table.pots.indexOf(pot) - 1).even(this);
            table.latestPot.adjustPot();
        } else
        {
            table.latestPot.contribute(this, called, false);
            table.latestPot.adjustPot();
        }

        table.adjustPots();
        money = money - called;
        p.methodsMisc.sendToAllWithinRange(table.location, p.PLUGIN_TAG + p.gold + name + p.white + " calls " + p.gold + p.methodsMisc.formatMoney(called) + p.white + " (Total: " + p.gold + p.methodsMisc.formatMoney(totalBet) + p.white + ")");
        stats.adjustStats("call", called);
        table.nextPersonTurn(this);
    }

    public void check()
    {
        // Simply say that the player has took action, and just send a message. Then go to the next player's turn
        action = false;
        acted = true;
        p.methodsMisc.sendToAllWithinRange(table.location, p.PLUGIN_TAG + p.gold + name + p.white + " checks.");
        table.nextPersonTurn(this);
    }

    public void clearBet()
    {
        currentBet = 0;
        acted = false;
    }

    // Clears the player's hand
    public void clearHand()
    {
        cards.clear();
    }

    // Displays the player's hand (to himself only)
    public void displayHand()
    {
        sendMessage(p.PLUGIN_TAG + "Your hand:");
        sendMessage(p.PLUGIN_TAG + p.gold + p.LINE_STRING);
        sendMessage(hand());
    }

    // Displays the player's money (to himself only)
    public void displayMoney()
    {
        sendMessage(p.PLUGIN_TAG + "You have " + p.gold + p.methodsMisc.formatMoney(money) + p.white + " left on this table.");
        sendMessage(p.PLUGIN_TAG + "Average stack size: " + p.gold + p.methodsMisc.formatMoney(table.getAverageStack(false)));
    }

    // Displays all pots at the table (to the player only)
    public void displayPot()
    {
        for (String temp : table.displayPots())
            sendMessage(temp);
    }

    // Eliminates the player by setting their eliminated flag to true and teleporting them to their starting location
    public void eliminate()
    {
        p.methodsMisc.sendToAllWithinRange(table.location, p.PLUGIN_TAG + p.gold + name + p.white + " has been eliminated!");
        clearHand();
        eliminated = true;
    }

    // Clears the player's hand, sets their folded flag to true and displays a message. Then goes to the turn of the next player
    public void fold()
    {
        action = false;
        acted = true;
        folded = true;
        p.methodsMisc.sendToAllWithinRange(table.location, p.PLUGIN_TAG + p.gold + name + p.white + " folds.");
        clearHand();
        if (table.currentPhase != 4) stats.adjustStats("handLost", totalBet);
        totalBet = 0;
        table.adjustPots();
        table.nextPersonTurn(this);
    }

    // Returns an array which represents the string representation of each card in the player's hand
    public String[] hand()
    {
        String[] returnValue = new String[cards.size()];
        int i = 0;
        // Go through all cards, add them to the temporary array and then return the array.
        for (Card card : cards)
        {
            returnValue[i] = p.PLUGIN_TAG + "[" + (i + 1) + "] " + card.toString();
            i++;
        }
        return returnValue;
    }

    public void invite(Player toInvite, int id)
    {
        toInvite.sendMessage(p.PLUGIN_TAG + p.gold + name + p.white + " has invited you to his/her poker table! Sit with " + p.gold + "/poker sit " + id + " [buy-in]");
        sendMessage(p.PLUGIN_TAG + "You have invited " + p.gold + toInvite.getName() + p.white + " to your table.");
    }

    /*
     * Makes this player posts a blind. The argument should be one of the three: "small" - for the small blind "big" - for the big blind "ante" - for the ante
     */
    public void postBlind(String blind)
    {
        // Go through all possible blind types and set the amount variable to the corresponding value in the table settings
        double amount = 0;
        if (blind.equals("small blind"))
        {
            amount = table.sb;
            p.methodsMisc.sendToAllWithinRange(table.location, p.PLUGIN_TAG + p.gold + name + p.white + " has posted the small blind (" + p.gold + p.methodsMisc.formatMoney(amount) + p.white + ")");
        }
        if (blind.equals("big blind"))
        {
            amount = table.bb;
            p.methodsMisc.sendToAllWithinRange(table.location, p.PLUGIN_TAG + p.gold + name + p.white + " has posted the big blind (" + p.gold + p.methodsMisc.formatMoney(amount) + p.white + ")");
        }
        if (blind.equals("ante"))
        {
            amount = table.ante;
            p.methodsMisc.sendToAllWithinRange(table.location, p.PLUGIN_TAG + p.gold + name + p.white + " has posted the ante (" + p.gold + p.methodsMisc.formatMoney(amount) + p.white + ")");
        }

        // Set the player's current bet to the blind, add the blind to their total amount, set the table's current bet to the amount, add the blind to the main pot, deduct money from the player
        currentBet = amount;
        totalBet = totalBet + amount;
        table.currentBet = amount;
        table.latestPot.contribute(this, amount, false);
        table.latestPot.pot = table.latestPot.pot + amount;
        money = money - amount;
    }

    // Called whenever the player wants to add more money to his/her stack (/hand rebuy)
    public void reBuy(double amount)
    {
        // Withdraw the desired amount from the ECONOMY, add it to their stack, then display the message
        p.ECONOMY.withdrawPlayer(name, amount);
        p.methodsMisc.addToLog(p.getDate() + " [ECONOMY] Withdrawing " + amount + " from " + name);
        money = money + amount;
        p.methodsMisc.sendToAllWithinRange(table.location, p.PLUGIN_TAG + p.gold + name + p.white + " has added " + p.gold + p.methodsMisc.formatMoney(amount) + p.white + " to his stack. New balance: " + p.gold + p.methodsMisc.formatMoney(money));
        // If the player was eliminated then get them back into the game
        if (eliminated == true && money > table.getHighestBlind())
        {
            p.methodsMisc.sendToAllWithinRange(table.location, p.PLUGIN_TAG + p.gold + name + p.white + " is now back in the game!");
            eliminated = false;
            if (table.getEliminatedPlayers().size() <= table.players.size() - 2) table.stopped = false;
        }
    }

    // Publicly reveals the player's hand to everybody
    public void revealHand()
    {
        revealed = true;
        acted = true;
        action = false;
        p.methodsMisc.sendToAllWithinRange(table.location, p.PLUGIN_TAG + "[" + id + "] " + p.gold + name + p.white + "'s hand:");
        p.methodsMisc.sendToAllWithinRange(table.location, hand());
        table.nextPersonTurn(this);
    }

    // Simply a shortcut method to send a message just to this poker player
    public void sendMessage(String message)
    {
        Player player = p.methodsMisc.getPlayer(name);
        if (player != null) player.sendMessage(message);
    }

    // Same as above except it takes an array argument
    public void sendMessage(String[] message)
    {
        Player player = p.methodsMisc.getPlayer(name);
        if (player != null) player.sendMessage(message);
    }

    // Sets the player's action flag to true and gives them an eye-catching message
    public void takeAction()
    {
        if (table.displayTurnsPublicly) p.methodsMisc.sendToAllWithinRange(table.location, p.PLUGIN_TAG + ChatColor.DARK_PURPLE + ChatColor.UNDERLINE + "It is " + p.gold + ChatColor.UNDERLINE + name + ChatColor.DARK_PURPLE + ChatColor.UNDERLINE + "'s turn to act!");
        else sendMessage(p.PLUGIN_TAG + ChatColor.DARK_PURPLE + ChatColor.UNDERLINE + "It is your turn to act!");
        action = true;
        p.methodsSound.playerTurn(p.methodsMisc.getPlayer(name));
    }
}
